// src/pages/api/query-with-sdk.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { createPublicClient, http, decodeEventLog } from 'viem';
import { somniaTestnet } from 'viem/chains';
import { normalizePhone, hashPhone } from '../../lib/phone';
import { sdk } from '../../lib/somnia';

const CONTRACT_ADDRESS = '0x6AB397FF662e42312c003175DCD76EfF69D048Fc';

// Event signature for UserRegistrationBroadcast
const eventAbi = {
  type: 'event',
  name: 'UserRegistrationBroadcast',
  inputs: [
    { name: 'phoneHash', type: 'bytes32', indexed: true },
    { name: 'walletAddress', type: 'address', indexed: false },
    { name: 'registeredAt', type: 'uint64', indexed: false }
  ]
} as const;

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'method not allowed' });
  }

  try {
    const phone = req.query.phone as string;
    
    if (!phone) {
      return res.status(400).json({ error: 'phone parameter required' });
    }

    const rpcUrl = process.env.RPC_URL;
    if (!rpcUrl) {
      return res.status(500).json({ error: 'RPC_URL not configured' });
    }

    // normalize & hash
    const normalized = normalizePhone(phone);
    const phoneHash = hashPhone(normalized);

    // Create viem client for events
    const client = createPublicClient({
      chain: somniaTestnet,
      transport: http(rpcUrl)
    });

    // 1. Query user registration events (same as before)
    const latestBlock = await client.getBlockNumber();
    const CHUNK_SIZE = 1000;
    const MAX_CHUNKS = 10;
    
    let allLogs: any[] = [];
    let currentBlock = latestBlock;
    
    for (let i = 0; i < MAX_CHUNKS; i++) {
      const fromBlock = currentBlock - BigInt(CHUNK_SIZE);
      
      const logs = await client.getLogs({
        address: CONTRACT_ADDRESS,
        event: eventAbi,
        args: {
          phoneHash: phoneHash as `0x${string}`
        },
        fromBlock,
        toBlock: currentBlock
      });
      
      if (logs.length > 0) {
        allLogs.push(...logs);
        if (i >= 3) break;
      }
      
      currentBlock = fromBlock - BigInt(1);
      if (currentBlock < 0) break;
    }

    // 2. Query price threshold using SDK
    let priceThresholds: any[] = [];
    
    try {
      console.log('Trying to get price threshold data using SDK...');
      
      // Try to get the last published price threshold for this phone
      const priceSchemaId = await sdk.streams.idToSchemaId('priceThreshold');
      console.log('Price schema ID:', priceSchemaId);
      
      if (priceSchemaId && priceSchemaId !== '0x0000000000000000000000000000000000000000000000000000000000000000') {
        try {
          // Try SDK method to get data by phoneHash as key
          const thresholdData = await sdk.streams.getByKey('priceThreshold', phoneHash);
          console.log('Threshold data from SDK:', thresholdData);
          
          if (thresholdData) {
            priceThresholds.push({
              phoneHash: phoneHash,
              data: thresholdData,
              source: 'sdk-getByKey'
            });
          }
        } catch (e) {
          console.log('SDK getByKey failed:', (e as Error).message);
          
          // Fallback: try to get latest data for this schema
          try {
            const latestData = await sdk.streams.getLastPublishedDataForSchema('priceThreshold');
            console.log('Latest threshold data:', latestData);
            
            if (latestData) {
              priceThresholds.push({
                phoneHash: phoneHash,
                data: latestData,
                source: 'sdk-getLatest'
              });
            }
          } catch (e2) {
            console.log('SDK getLastPublished also failed:', (e2 as Error).message);
          }
        }
      }
    } catch (e) {
      console.error('Error querying price thresholds with SDK:', e);
    }

    // Process registration events
    const registrations = allLogs.map((log) => {
      const decoded = decodeEventLog({
        abi: [eventAbi],
        data: log.data,
        topics: log.topics
      });

      return {
        walletAddress: decoded.args.walletAddress,
        registeredAt: new Date(Number(decoded.args.registeredAt)).toISOString(),
        phoneHash: decoded.args.phoneHash,
        recordId: `${log.blockNumber}_${log.transactionIndex}_${log.logIndex}`
      };
    });

    // Build result
    const result = {
      phone: normalized,
      found: registrations.length > 0 || priceThresholds.length > 0,
      registrations: registrations,
      priceThresholds: priceThresholds,
      registrationCount: registrations.length,
      thresholdCount: priceThresholds.length,
      phoneHash: phoneHash
    };

    // Convert BigInt values to strings for JSON serialization
    return res.json(JSON.parse(JSON.stringify(result, (key, value) =>
      typeof value === 'bigint' ? value.toString() : value
    )));

  } catch (error: any) {
    console.error('Query error:', error);
    return res.status(500).json({ 
      error: 'Failed to query data',
      details: error.message
    });
  }
}