// src/pages/api/query-simple-meta.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { createPublicClient, http, decodeEventLog } from 'viem';
import { AbiCoder } from 'ethers';
import { somniaTestnet } from 'viem/chains';
import { normalizePhone, hashPhone } from '../../lib/phone';

const CONTRACT_ADDRESS = '0x6AB397FF662e42312c003175DCD76EfF69D048Fc';

// Event signature for UserRegistrationBroadcast
const eventAbi = {
  type: 'event',
  name: 'UserRegistrationBroadcast',
  inputs: [
    { name: 'phoneHash', type: 'bytes32', indexed: true },
    { name: 'walletAddress', type: 'address', indexed: false },
    { name: 'registeredAt', type: 'uint64', indexed: false }
  ]
} as const;

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    const phone = (req.method === 'GET' ? req.query.phone : req.body?.phone) as string;
    
    if (!phone) {
      return res.status(400).json({ error: 'phone parameter required' });
    }

    const rpcUrl = process.env.RPC_URL;
    if (!rpcUrl) {
      return res.status(500).json({ error: 'RPC_URL not configured' });
    }

    // normalize & hash
    const normalized = normalizePhone(phone);
    const phoneHash = hashPhone(normalized);

    // Create viem client
    const client = createPublicClient({
      chain: somniaTestnet,
      transport: http(rpcUrl)
    });

    console.log(`=== Querying phone: ${normalized}, hash: ${phoneHash} ===`);

    // Query user registration events
    const latestBlock = await client.getBlockNumber();
    const CHUNK_SIZE = 1000;
    const MAX_CHUNKS = 5;
    
    let allLogs: any[] = [];
    let currentBlock = latestBlock;
    
    for (let i = 0; i < MAX_CHUNKS; i++) {
      const fromBlock = currentBlock - BigInt(CHUNK_SIZE);
      
      const logs = await client.getLogs({
        address: CONTRACT_ADDRESS,
        event: eventAbi,
        args: {
          phoneHash: phoneHash as `0x${string}`
        },
        fromBlock,
        toBlock: currentBlock
      });
      
      if (logs.length > 0) {
        allLogs.push(...logs);
        console.log(`Found ${logs.length} registration events in block range ${fromBlock}-${currentBlock}`);
      }
      
      currentBlock = fromBlock - BigInt(1);
      if (currentBlock < 0) break;
    }

    // Process registrations and extract price thresholds from registration metadata
    const registrations = [];
    const priceThresholds = [];

    for (const log of allLogs) {
      const decoded = decodeEventLog({
        abi: [eventAbi],
        data: log.data,
        topics: log.topics
      });

      const registration = {
        walletAddress: decoded.args.walletAddress,
        registeredAt: new Date(Number(decoded.args.registeredAt)).toISOString(),
        phoneHash: decoded.args.phoneHash,
        recordId: `${log.blockNumber}_${log.transactionIndex}_${log.logIndex}`,
        transactionHash: log.transactionHash
      };
      
      registrations.push(registration);

      console.log(`\n=== Processing transaction: ${log.transactionHash} ===`);

      try {
        // Get transaction receipt and analyze all logs
        const receipt = await client.getTransactionReceipt({ hash: log.transactionHash });
        console.log(`Transaction has ${receipt.logs.length} total logs`);

        // Look for user registration data in this transaction
        for (let i = 0; i < receipt.logs.length; i++) {
          const txLog = receipt.logs[i];
          
          if (txLog.address.toLowerCase() === CONTRACT_ADDRESS.toLowerCase() && txLog.topics.length >= 2) {
            const dataId = txLog.topics[1];
            console.log(`\nTrying to get data for log ${i}, dataId: ${dataId}`);
            
            try {
              const data = await client.readContract({
                address: CONTRACT_ADDRESS,
                abi: [{
                  inputs: [{ name: 'id', type: 'bytes32' }],
                  name: 'get',
                  outputs: [{ name: '', type: 'bytes' }],
                  stateMutability: 'view',
                  type: 'function'
                }],
                functionName: 'get',
                args: [dataId]
              });

              console.log(`Got data: length=${data.length}`);

              if (data && data !== '0x' && data.length > 200) {
                const abiCoder = new AbiCoder();
                
                try {
                  // Try to decode as user registration: bytes32 phoneHash, address wallet, string metainfo, uint64 timestamp
                  const userDecoded = abiCoder.decode(
                    ['bytes32', 'address', 'string', 'uint64'],
                    data
                  );
                  
                  const [decodedPhoneHash, decodedWallet, metainfo, timestamp] = userDecoded;
                  console.log(`User data - phoneHash: ${decodedPhoneHash}, metainfo length: ${metainfo.length}`);
                  
                  if (decodedPhoneHash === phoneHash && metainfo && metainfo.length > 10) {
                    console.log(`Found user registration data! Metainfo: ${metainfo.substring(0, 200)}...`);
                    
                    try {
                      const metadata = JSON.parse(metainfo);
                      console.log('Parsed metadata keys:', Object.keys(metadata));
                      
                      if (metadata.hasThresholds && metadata.minLoss !== undefined && metadata.maxProfit !== undefined) {
                        console.log('✅ Found price thresholds in metadata!');
                        
                        priceThresholds.push({
                          dataId: metadata.priceDataId || dataId,
                          phoneHash: phoneHash,
                          tokenSymbol: metadata.tokenSymbol || 'STT',
                          minLossPercentage: Number(metadata.minLoss),
                          maxProfitPercentage: Number(metadata.maxProfit),
                          updatedAt: Number(timestamp),
                          source: 'metadata',
                          transactionHash: log.transactionHash
                        });
                        
                        console.log(`Added threshold: ${metadata.minLoss}% loss, ${metadata.maxProfit}% profit`);
                      } else {
                        console.log('❌ No threshold data in metadata');
                      }
                    } catch (e) {
                      console.log('❌ Could not parse metainfo JSON:', e.message);
                      console.log('Raw metainfo:', metainfo);
                    }
                  }
                } catch (e) {
                  // Not user registration data, maybe price threshold data
                  try {
                    const priceDecoded = abiCoder.decode(
                      ['bytes32', 'string', 'uint256', 'uint256', 'uint64'],
                      data
                    );
                    
                    if (priceDecoded[0] === phoneHash) {
                      console.log('✅ Found direct price threshold data!');
                      priceThresholds.push({
                        dataId: dataId,
                        phoneHash: priceDecoded[0],
                        tokenSymbol: priceDecoded[1],
                        minLossPercentage: Number(priceDecoded[2]),
                        maxProfitPercentage: Number(priceDecoded[3]),
                        updatedAt: Number(priceDecoded[4]),
                        source: 'direct',
                        transactionHash: log.transactionHash
                      });
                    }
                  } catch (e2) {
                    console.log('Not price threshold data either');
                  }
                }
              }
            } catch (e) {
              console.log(`Could not get data for ${dataId}:`, e.message);
            }
          }
        }
      } catch (e) {
        console.error('Error processing transaction:', e.message);
      }
    }

    console.log(`\n=== FINAL RESULT: ${registrations.length} registrations, ${priceThresholds.length} price thresholds ===`);

    const result = {
      phone: normalized,
      found: registrations.length > 0 || priceThresholds.length > 0,
      registrations: registrations,
      priceThresholds: priceThresholds,
      registrationCount: registrations.length,
      thresholdCount: priceThresholds.length,
      debug: {
        phoneHash,
        latestBlock: latestBlock.toString(),
        searchedBlocks: MAX_CHUNKS * CHUNK_SIZE
      }
    };

    return res.json(JSON.parse(JSON.stringify(result, (key, value) =>
      typeof value === 'bigint' ? value.toString() : value
    )));

  } catch (error: any) {
    console.error('Query error:', error);
    return res.status(500).json({ 
      error: 'Failed to query data',
      details: error.message
    });
  }
}