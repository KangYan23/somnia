// src/pages/api/query-tx-based.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { createPublicClient, http, decodeEventLog } from 'viem';
import { AbiCoder } from 'ethers';
import { somniaTestnet } from 'viem/chains';
import { normalizePhone, hashPhone } from '../../lib/phone';

const CONTRACT_ADDRESS = '0x6AB397FF662e42312c003175DCD76EfF69D048Fc';

// Event signature for UserRegistrationBroadcast
const eventAbi = {
  type: 'event',
  name: 'UserRegistrationBroadcast',
  inputs: [
    { name: 'phoneHash', type: 'bytes32', indexed: true },
    { name: 'walletAddress', type: 'address', indexed: false },
    { name: 'registeredAt', type: 'uint64', indexed: false }
  ]
} as const;

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    const phone = (req.method === 'GET' ? req.query.phone : req.body?.phone) as string;
    
    if (!phone) {
      return res.status(400).json({ error: 'phone parameter required' });
    }

    const rpcUrl = process.env.RPC_URL;
    if (!rpcUrl) {
      return res.status(500).json({ error: 'RPC_URL not configured' });
    }

    // normalize & hash
    const normalized = normalizePhone(phone);
    const phoneHash = hashPhone(normalized);

    // Create viem client
    const client = createPublicClient({
      chain: somniaTestnet,
      transport: http(rpcUrl)
    });

    console.log(`Querying for phone: ${normalized}, hash: ${phoneHash}`);

    // Query user registration events
    const latestBlock = await client.getBlockNumber();
    const CHUNK_SIZE = 1000;
    const MAX_CHUNKS = 5;
    
    let allLogs: any[] = [];
    let currentBlock = latestBlock;
    
    for (let i = 0; i < MAX_CHUNKS; i++) {
      const fromBlock = currentBlock - BigInt(CHUNK_SIZE);
      
      const logs = await client.getLogs({
        address: CONTRACT_ADDRESS,
        event: eventAbi,
        args: {
          phoneHash: phoneHash as `0x${string}`
        },
        fromBlock,
        toBlock: currentBlock
      });
      
      if (logs.length > 0) {
        allLogs.push(...logs);
        console.log(`Found ${logs.length} registration events in block range ${fromBlock}-${currentBlock}`);
      }
      
      currentBlock = fromBlock - BigInt(1);
      if (currentBlock < 0) break;
    }

    // Process registrations and extract price thresholds from transaction data
    const registrations = [];
    const priceThresholds = [];

    for (const log of allLogs) {
      const decoded = decodeEventLog({
        abi: [eventAbi],
        data: log.data,
        topics: log.topics
      });

      const registration = {
        walletAddress: decoded.args.walletAddress,
        registeredAt: new Date(Number(decoded.args.registeredAt)).toISOString(),
        phoneHash: decoded.args.phoneHash,
        recordId: `${log.blockNumber}_${log.transactionIndex}_${log.logIndex}`,
        transactionHash: log.transactionHash
      };
      
      registrations.push(registration);

      console.log(`Processing transaction: ${log.transactionHash}`);

      try {
        // Get the full transaction receipt to see all data stored
        const receipt = await client.getTransactionReceipt({ hash: log.transactionHash });
        
        console.log(`Transaction has ${receipt.logs.length} logs`);

        // Look for data storage events in the same transaction
        for (let i = 0; i < receipt.logs.length; i++) {
          const txLog = receipt.logs[i];
          console.log(`Log ${i}: address=${txLog.address}, topics=${txLog.topics.length}`);
          
          if (txLog.address.toLowerCase() === CONTRACT_ADDRESS.toLowerCase()) {
            // This is a contract event, try to get the data
            if (txLog.topics.length >= 2) {
              const dataId = txLog.topics[1]; // Usually the data ID
              console.log(`Trying to get data for ID: ${dataId}`);
              
              try {
                const data = await client.readContract({
                  address: CONTRACT_ADDRESS,
                  abi: [{
                    inputs: [{ name: 'id', type: 'bytes32' }],
                    name: 'get',
                    outputs: [{ name: '', type: 'bytes' }],
                    stateMutability: 'view',
                    type: 'function'
                  }],
                  functionName: 'get',
                  args: [dataId]
                });

                console.log(`Data for ${dataId}: length=${data.length}`);

                if (data && data !== '0x' && data.length > 100) {
                  const abiCoder = new AbiCoder();
                  
                  try {
                    // Try to decode as user registration data first
                    const userDecoded = abiCoder.decode(
                      ['bytes32', 'address', 'string', 'uint64'],
                      data
                    );
                    
                    console.log('Successfully decoded as user data, checking metainfo...');
                    const metainfo = userDecoded[2];
                    console.log('Metainfo:', metainfo);
                    
                    if (metainfo && metainfo.includes('priceDataId')) {
                      try {
                        const metadata = JSON.parse(metainfo);
                        console.log('Parsed metadata:', metadata);
                        
                        if (metadata.priceDataId) {
                          console.log('Found priceDataId in metadata:', metadata.priceDataId);
                          
                          // Get the price threshold data
                          try {
                            const priceData = await client.readContract({
                              address: CONTRACT_ADDRESS,
                              abi: [{
                                inputs: [{ name: 'id', type: 'bytes32' }],
                                name: 'get',
                                outputs: [{ name: '', type: 'bytes' }],
                                stateMutability: 'view',
                                type: 'function'
                              }],
                              functionName: 'get',
                              args: [metadata.priceDataId]
                            });

                            console.log(`Price data for ${metadata.priceDataId}: length=${priceData.length}`);

                            if (priceData && priceData !== '0x') {
                              // Add from metadata as fallback + try to decode stored data
                              priceThresholds.push({
                                dataId: metadata.priceDataId,
                                phoneHash: phoneHash,
                                tokenSymbol: metadata.tokenSymbol || 'STT',
                                minLossPercentage: metadata.minLoss || 0,
                                maxProfitPercentage: metadata.maxProfit || 0,
                                updatedAt: Date.now(),
                                source: 'metadata'
                              });

                              // Also try to decode the actual stored price data
                              try {
                                const priceDecoded = abiCoder.decode(
                                  ['bytes32', 'string', 'uint256', 'uint256', 'uint64'],
                                  priceData
                                );
                                
                                priceThresholds.push({
                                  dataId: metadata.priceDataId,
                                  phoneHash: priceDecoded[0],
                                  tokenSymbol: priceDecoded[1],
                                  minLossPercentage: Number(priceDecoded[2]),
                                  maxProfitPercentage: Number(priceDecoded[3]),
                                  updatedAt: Number(priceDecoded[4]),
                                  source: 'decoded'
                                });
                              } catch (e) {
                                console.log('Could not decode price data, using metadata values');
                              }
                            }
                          } catch (e) {
                            console.error('Error getting price data:', e.message);
                            // Still add from metadata
                            priceThresholds.push({
                              dataId: metadata.priceDataId,
                              phoneHash: phoneHash,
                              tokenSymbol: metadata.tokenSymbol || 'STT',
                              minLossPercentage: metadata.minLoss || 0,
                              maxProfitPercentage: metadata.maxProfit || 0,
                              updatedAt: Date.now(),
                              source: 'metadata-only'
                            });
                          }
                        }
                      } catch (e) {
                        console.log('Could not parse metainfo JSON:', e.message);
                      }
                    }
                  } catch (e) {
                    // Not user registration data, maybe it's price threshold data directly
                    try {
                      const priceDecoded = abiCoder.decode(
                        ['bytes32', 'string', 'uint256', 'uint256', 'uint64'],
                        data
                      );
                      
                      if (priceDecoded[0] === phoneHash) {
                        console.log('Found direct price threshold data');
                        priceThresholds.push({
                          dataId: dataId,
                          phoneHash: priceDecoded[0],
                          tokenSymbol: priceDecoded[1],
                          minLossPercentage: Number(priceDecoded[2]),
                          maxProfitPercentage: Number(priceDecoded[3]),
                          updatedAt: Number(priceDecoded[4]),
                          source: 'direct'
                        });
                      }
                    } catch (e2) {
                      console.log('Not price threshold data either');
                    }
                  }
                }
              } catch (e) {
                console.log(`Could not get data for ${dataId}:`, e.message);
              }
            }
          }
        }
      } catch (e) {
        console.error('Error processing transaction:', e.message);
      }
    }

    console.log(`Found ${registrations.length} registrations, ${priceThresholds.length} price thresholds`);

    const result = {
      phone: normalized,
      found: registrations.length > 0 || priceThresholds.length > 0,
      registrations: registrations,
      priceThresholds: priceThresholds,
      registrationCount: registrations.length,
      thresholdCount: priceThresholds.length,
      debug: {
        phoneHash,
        latestBlock: latestBlock.toString(),
        searchedBlocks: MAX_CHUNKS * CHUNK_SIZE
      }
    };

    return res.json(JSON.parse(JSON.stringify(result, (key, value) =>
      typeof value === 'bigint' ? value.toString() : value
    )));

  } catch (error: any) {
    console.error('Query error:', error);
    return res.status(500).json({ 
      error: 'Failed to query data',
      details: error.message
    });
  }
}